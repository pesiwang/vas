/*
 * VasEventbase.cpp
 *
 *  Created on: Jan 22, 2015
 *      Author: ray
 */

#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/epoll.h>
#include "core/VasEventbase.h"
#include "core/VasException.h"
#include "core/VasHelper.h"

using namespace std;

VasEventbase::VasEventbase() : _serviceState(ServiceStateStopped), _epollFd(-1) {
	this->_epollFd = ::epoll_create(64);
	if (this->_epollFd < 0) {
		throw VasException("cannot create epoll file descriptor");
	}

	if(!VasHelper::Application::setSignalHandler(SIGPIPE, SIG_IGN)) {
		throw VasException("failed to set SIGPIPE to SIG_IGN");
	}

	if (!VasHelper::Application::setSignalHandler(SIGINT, VasEventbase::stop)) {
		throw VasException("failed to set SIGINT to VasEventbase::stop");
	}
}

VasEventbase::~VasEventbase() {
	if (this->_epollFd >= 0) {
		::close(this->_epollFd);
		this->_epollFd = -1;
	}
}

VasEventbase *VasEventbase::instance(){
	static VasEventbase self;
	return &self;
}

void VasEventbase::stop(int sig){
	VasEventbase::instance()->_serviceState = ServiceStateStopping;
}

void VasEventbase::addListenerSocket(int fd, VasListenerHandler *handler) {
	if (this->_sockets.find(fd) != this->_sockets.end()) {
		VAS_LOGGER_ERROR("cannot add a listener socket on fd = %d", fd);
		return;
	}
	struct epoll_event ev = {0};
	ev.events = EPOLLIN;
	ev.data.fd = fd;
	if(::epoll_ctl(this->_epollFd, EPOLL_CTL_ADD, fd, &ev) < 0){
		VAS_LOGGER_ERROR("failed to add listener socket %d to epoll", fd);
		return;
	}

	Socket* socket = new Socket();
	socket->handler = handler;
	socket->state = SocketStateConnected;
	socket->type = SocketTypeListener;
	this->_sockets[fd] = socket;
}

void VasEventbase::addClientSocket(int fd, VasClientHandler *handler) {
	if (this->_sockets.find(fd) != this->_sockets.end()) {
		VAS_LOGGER_ERROR("cannot add a client socket on fd = %d", fd);
		return;
	}
	struct epoll_event ev = {0};
	ev.events = EPOLLIN|EPOLLOUT;
	ev.data.fd = fd;
	if(::epoll_ctl(this->_epollFd, EPOLL_CTL_ADD, fd, &ev) < 0){
		VAS_LOGGER_ERROR("failed to add client socket %d to epoll", fd);
		return;
	}

	Socket* socket = new Socket();
	socket->handler = handler;
	socket->state = SocketStateConnecting;
	socket->type = SocketTypeClient;
	this->_sockets[fd] = socket;
}

void VasEventbase::addServerSocket(int fd, VasServerHandler *handler) {
	if (this->_sockets.find(fd) != this->_sockets.end()) {
		VAS_LOGGER_ERROR("cannot add a server socket on fd = %d", fd);
		return;
	}
	struct epoll_event ev = {0};
	ev.events = EPOLLIN;
	ev.data.fd = fd;
	if(::epoll_ctl(this->_epollFd, EPOLL_CTL_ADD, fd, &ev) < 0){
		VAS_LOGGER_ERROR("failed to add server socket %d to epoll", fd);
		return;
	}

	Socket* socket = new Socket();
	socket->handler = handler;
	socket->state = SocketStateConnected;
	socket->type = SocketTypeClient;
	this->_sockets[fd] = socket;
}

void VasEventbase::connectSocket(int fd) {
	map<int, Socket* >::iterator iter = this->_sockets.find(fd);
	if (iter == this->_sockets.end()) {
		VAS_LOGGER_ERROR("cannot connect socket with fd = %d", fd);
		return;
	}

	struct epoll_event ev = {0};
	ev.data.fd = fd;
	ev.events = EPOLLIN;
	if(::epoll_ctl(this->_epollFd, EPOLL_CTL_MOD, fd, &ev) < 0){
		VAS_LOGGER_ERROR("failed to mod server socket %d to epoll", fd);
		this->removeSocket(fd);
		return;
	}

	Socket *socket = iter->second;
	socket->state = SocketStateConnected;
	(static_cast<VasClientHandler *>(socket->handler))->onConnected(fd);
}

void VasEventbase::writeSocket(int fd, VasBuffer *buffer) {
	if (!VasHelper::Socket::write(fd, buffer)) {
		this->removeSocket(fd);
		return;
	}

	struct epoll_event ev = {0};
	ev.data.fd = fd;
	if (buffer->size() > 0) {
		ev.events = EPOLLIN|EPOLLOUT;
	}
	else {
		ev.events = EPOLLIN;
	}

	if(::epoll_ctl(this->_epollFd, EPOLL_CTL_MOD, fd, &ev) < 0){
		VAS_LOGGER_ERROR("failed to mod server socket %d to epoll", fd);
		this->removeSocket(fd);
		return;
	}
}

void VasEventbase::removeSocket(int fd) {
	map<int, Socket* >::iterator iter = this->_sockets.find(fd);
	if (iter == this->_sockets.end()) {
		VAS_LOGGER_ERROR("cannot remove socket with fd = %d", fd);
		return;
	}

	iter->second->state = SocketStateClosing;
	this->_closingSockets.insert(fd);
}

void VasEventbase::dispatch() {
	this->_serviceState = ServiceStateRunning;
	while (ServiceStateRunning == this->_serviceState) {
		VasHelper::Clock::sync();
		struct epoll_event events[64];
		int nfds = epoll_wait(this->_epollFd, events, 64, 1000);
		if (nfds < 0)
			continue;

		for (int i = 0; i < nfds; ++i) {
			int targetFd = events[i].data.fd;
			uint32_t targetEvents = events[i].events;

			map<int, Socket* >::iterator iter = this->_sockets.find(targetFd);
			if ((iter == this->_sockets.end()) || (iter->second->state == SocketStateClosed) || (iter->second->state == SocketStateClosing))
				continue;

			Socket *stub = iter->second;
			switch(stub->type) {
				case SocketTypeListener:
					if ((targetEvents & EPOLLIN) && (stub->state == SocketStateConnected)) {
						int clientFd = -1;
						while((clientFd = VasHelper::Socket::accept(targetFd)) >= 0)
							(static_cast<VasListenerHandler *>(stub->handler))->onAccepted(clientFd);
					}
					break;
				case SocketTypeClient:
					if ((targetEvents & EPOLLIN) && (stub->state == SocketStateConnected)) {
						if (VasHelper::Socket::read(targetFd, &(stub->input))) {
							(static_cast<VasClientHandler *>(stub->handler))->onDataArrived(targetFd);
						}
						else {
							this->removeSocket(targetFd);
						}
					}
					else if ((targetEvents & EPOLLOUT) && ((stub->state == SocketStateConnecting) || (stub->state == SocketStateConnected))) {
						if (stub->state == SocketStateConnecting) {
							this->connectSocket(targetFd);
						}
						else {
							this->writeSocket(targetFd, &(stub->output));
						}
					}
					break;
				case SocketTypeServer:
					if ((targetEvents & EPOLLIN) && (stub->state == SocketStateConnected)) {
						if (VasHelper::Socket::read(targetFd, &(stub->input))) {
							(static_cast<VasServerHandler *>(stub->handler))->onDataArrived(targetFd);
						}
						else {
							this->removeSocket(targetFd);
						}
					}
					else if ((targetEvents & EPOLLOUT) && (stub->state == SocketStateConnected)) {
						this->writeSocket(targetFd, &(stub->output));
					}
					break;
				default:
					break;
			}
		}

		this->_cleanupRunloop();
	}

	this->_cleanupService();
	this->_serviceState = ServiceStateStopped;
}

/////////////////////////////////////////////////////////////////////
void VasEventbase::_cleanupRunloop() {
	for (set<int>::iterator iter = this->_closingSockets.begin(); iter != this->_closingSockets.end(); ++iter) {
		int targetFd = *iter;
		map<int, Socket* >::iterator subIter = this->_sockets.find(targetFd);
		if (subIter == this->_sockets.end()) {
			continue;
		}

		::close(targetFd);
		subIter->second->handler->onClosed(targetFd);
		this->_sockets.erase(subIter);
	}

	this->_closingSockets.clear();
}

void VasEventbase::_cleanupService() {
	for (map<int, Socket* >::iterator iter = this->_sockets.begin(); iter != this->_sockets.end(); ++iter) {
		if (iter->second->state != SocketStateClosing)
			this->removeSocket(iter->first);
	}
}
